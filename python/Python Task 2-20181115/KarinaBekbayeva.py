
from scipy import *
from scipy.linalg import *
# Task number 4 
#
#  h    |  10^-3                           |  2.10^-3                         | 4.10^-3
#_________________________________________________________________________________________________________________
# Euler |[-0.00304834, -0.00497444]        |[-0.00608604, -0.00992802]        |[-0.01212979, -0.01977312]
#_________________________________________________________________________________________________________________
# Heun  |[-1.03556852e-06, -1.38790976e-06]|[-4.13730925e-06, -5.54565811e-06]|[-1.65094891e-05, -2.21345750e-05]
#_________________________________________________________________________________________________________________
# Runge-|
# Kutta |[-1.67421632e-13, -2.38031816e-13]|[-2.66120459e-12, -3.72901710e-12]|[-4.24467128e-11, -5.95541394e-11]
#_________________________________________________________________________________________________________________
#
#
# Task number 5
# N = 100
# h = 4.10^-3       Standard Runge-Kutta
# C++    time:  0.00036s
# Python time:  0.01690s

# h = 10^-3         Heun
# C++    time:	0.00058s
# Python time:  0.03556s

# h = 2.10^-3       Euler
# C++    time:  0.00039s
# Python time:  0.00766s

# runge_kutta1 is Euler's method:

def runge_kutta1( F, x, h ) : 
   k1 = F( x ) 

   return x + h * k1 

def runge_kutta21( F, x,h):
   k1 = F(x)
   k2 = F( x +h*k1)
   return x+h *(0.5*k1 + 0.5*k2)

def runge_kutta22(F, x , h):
   k1 = f(h)
   k2 = f(x +0.5*h*k1)
   return x+h * k2

def runge_kutta31( x, F, h):
   k1 = F( x )
   k2 = F(x+ h *(2/3)*k1 )
   k3 = F( x + h*((1/3)*k1 + (1/3)*k2))
   return x + h *( (1/4)*k1 +(3/4)*k3 )

def runge_kutta41(F,x,h):
   k1 = F(x)
   k2 = F( x + 0.5 * h * k1 )
   k3 = F( x + 0.5 * h * k2 )
   k4 = F( x + h * k3 )
   return x + ( 1.0 / 6.0 ) * h * ( k1 + 2.0 * k2 + 2.0 * k3 + k4 )

def runge_kutta4_kuntzmann(x, F, h):
   k1 = f( x )
   k2 = f( x + h * (2.0/5.0) * k1 )
   k3 = f( x + h * ( (-3.0/20.0) * k1 + (3.0/4.0) * k2 ) )
   k4 = f( x + h * ( (19.0/44.0) * k1 + (-15.0/44.0) * k2 + (40.0/44.0) * k3 ) )
   return x + h * ( (55.0/360.0) * k1 + (125.0/360.0) * k2 + (125.0/360.0) * k3 + (55.0/360.0) * k4 )

def runge_kutta5(F,x,h):
   k1 = f( x )
   k2 = f( x + h * (1.0/4.0) * k1 )
   k3 = f( x + h * ( (1.0/8.0) * k1 + (1.0/8.0) * k2 ) )
   k4 = f( x + h * (1.0/2.0) * k3 )
   k5 = f( x + h * ( (3.0/16.0) * k1 + (-3.0/8.0) * k2 +(3.0/8.0) * k3 + (9.0/16.0) * k4 ) )
   k6 = f( x + h * ( (-3.0/7.0) * k1 + (8.0/7.0) * k2 +(6.0/7.0) * k3 + (-12.0/7.0) * k4 +(8.0/7.0) * k5 ) )
   return x + h * (   ( 7.0 / 90.0 ) * k1 + ( 32.0 / 90.0 ) * k3 + ( 12.0 / 90.0 ) * k4 + ( 32.0 / 90.0 ) * k5 +( 7.0 / 90.0 ) * k6 )


#0.05339774847030640.0533977484703060.05339774847030644
def approx( h = 2.0E-3 ) :
   print( "testing Runge-Kutta methods on the catenary" )

   x0 = 0.0
   x1 = 1.0

   mu = 2.0

   s0 = array( [ 1.0 / mu, 0.0 ] )

   p = s0
   x = x0

   def cat( p ) :
      return array( [ p[1], mu * sqrt( 1.0 + p[1] * p[1] ) ] )

   while x + h < x1 :
      p = runge_kutta1( cat, p, h )
      x += h

   p = runge_kutta1( cat, p, x1 - x )
   x = x1

   print( "h = ", h )
   print( "final value = ", p )

   expected = array( [ cosh( mu * x1 ) / mu, sinh( mu * x1 ) ] )
   error = p - expected

   print( "error = ", error )


